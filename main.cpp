////////////////////////////////////////////////////
// DO NOT EDIT THIS FILE
//
// Compile this file using Clang, gcc, or
// Microsoft Visual Studio C++ compiler.
//
// To compile using Clang type: make
//

#include <string>
#include <vector>

#include "assignment1.h"
#include "test_framework.h"

const char *smallDataset = "small_problem_set_1.in";
const char *largeDataset = "large_problem_set_1.in";

const char *helpMsg = "Please, indicate which"
                      "problem set to use.\n\n"
                      "For small problem set, "
                      "type: ./main small\n"
                      "For large problem set, "
                      "type: ./main large\n";

const char *strNotice = "##################################\n"
                        "# Do not edit this file!\n"
                        "##################################\n";

constexpr int problem_set_id = 1;

struct ProblemN1 : public TestFramework::BasicProblem
{
    std::vector<int> encryptedName;
    int n;
    std::string restaurantList;
};

int main(int argc, char *argv[])
{
    using namespace TestFramework;

    static_assert(
        GetTestFrameworkVersion() == 10,
        "TestFramework version 10 is required. Please, update test_framework.h.");

    if ((argc != 2) && (argc != 3))
    {
        std::cout << helpMsg;
    }

    std::string firstArg(DefaultProblemSet());

    if (argc >= 2)
    {
        firstArg = argv[1];
    }
    else
    {
        std::cout << "\nUsing the default problem set: " << firstArg;
    }

    ThrowIfConditionFails((firstArg == "small") || (firstArg == "large"),
                          "Unknown problem set.");
    bool bSmallDataset = (firstArg == "small");

    std::cout << std::endl
              << "Problem set #" << problem_set_id << ". ";

    ProblemSetHeader header;
    RecordAdapter<ProblemSetHeader> psAdapter(header);
    AddDefaultProblemSetColumns(psAdapter);

    std::vector<ProblemN1> problems;
    TableAdapter<ProblemN1> prAdapter(problems);
    AddDefaultProblemColumns(prAdapter);

    AddColumn<ProblemN1>(prAdapter, "encryptedName", &ProblemN1::encryptedName);
    AddColumn<ProblemN1>(prAdapter, "n", &ProblemN1::n);
    AddColumn<ProblemN1>(prAdapter, "restaurantList", &ProblemN1::restaurantList);

    BasicYamlParser parser(dynamic_cast<ITable *>(&psAdapter),
                           dynamic_cast<ITable *>(&prAdapter));

    const char *inputFilename = bSmallDataset ? smallDataset : largeDataset;
    std::cout << "File: " << inputFilename << ".\n";

    try
    {
        parser.ParseFile(inputFilename, true);
    }
    catch (const TestFramework::ParseError &e)
    {
        std::cerr
            << e.file << ":" << e.line
            << ": parse error: " << e.what() << '\n';
        return 1;
    }
    catch (const TestFramework::TestFrameworkError &e)
    {
        std::cerr << "Error: " << e.what() << '\n';
        return 1;
    }

    PreprocessProblemSet(problem_set_id, problems, header);

    for (int i = 0; i < problems.size(); ++i)
    {
        auto &theProblem = problems[i];
        theProblem.student_answer = FindKey(theProblem.encryptedName, theProblem.n,
                                            theProblem.restaurantList);
    }

    ProcessResults(problems, header);

    std::cout << "Don't forget to submit your "
                 "source code on Canvas.";

    std::cout << "\nRunning time: ";
    std::cout << header.time << "ms";
    std::cout << std::endl
              << std::endl;
    std::cout << std::endl
              << std::endl;

    if (argc == 3)
    {
        const char *outputFilename = argv[2];
        std::cout << "Generating a report. ";
        std::cout << "The report is saved in file '";
        std::cout << outputFilename << "'.\n";
        TableAdapter<ProblemN1> prOutAdapter(problems);
        AddDefaultProblemColumnsForOutput(prOutAdapter);

        WriteTableToFile(outputFilename, &psAdapter, &prOutAdapter, true,
                         strNotice);
    }

    return 0;
}
